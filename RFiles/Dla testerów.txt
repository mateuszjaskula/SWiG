
#Wczytaj dwa utwory
u1 = readMP3("u1.mp3")
u2 = readMP3("u2.mp3")
u1 = mono(u1,which="left")
u2 = mono(u2,which="left")

#Wytnij np po³owê utworu (ze œrodka)
#MiddlePerc jest w Podstawowe funkcje.R
#Pasowa³oby przetestowaæ czy zmiana d³ugoœci przetwarzanego sygna³u ma jakieœ wielkie znaczenie. Mo¿e wystarczy np 25% utworu
u1 = MiddlePerc(u1, 50) #wycina 50% ze œrodka
u2 = MiddlePerc(u2, 50) #wycina 50% ze œrodka

#Albo 2 minity ze œrodka
u1 = Middle(u1, 120) #wycina 120s ze œrodka
u2 = Middle(u2, 120) #wycina 120s ze œrodka

#normalizowanie
u1@left = u1@left/2^(u1@bit-1)
u2@left = u2@left/2^(u2@bit-1)

#Wylicz MFCC 
#Tutaj mo¿na potestowaæ jaka szerokoœæ okna bêdzie najlepsza i jaki wybraæ overlaping (ewentualnie jakieœ inne parametry funkcji melfcc)
#Funckja MFCC jest w Podstawowe funkcje.R
d1 = MFCC(u1)
d2 = MFCC(u2)

#Porówynywanie funkcj¹ GetMeanAndStd
w1 = GetMeanAndStd(u1)
w2 = GetMeanAndStd(u2)

#Porównywanie wyników
#RMS jest w Podstawowe funkcje.R
wynik1 = RMS(d1$meanVal, d2$meanVal) #Porównanie œrednich
wynik2 = RMS(d1$stdVal, d2$stdVal) #Porównanie odchyleñ
wynik3 = RMS(d1$Delta_meanVal, d2$Delta_meanVal) #Porównanie œrednich delty
wynik4 = RMS(d1$Delta_stdVal, d2$Delta_stdVal) #Porównanie odchyleñ delty

#Suma wa¿ona wyników
wynik = a*wynik1+b*wynik2+c*wynik3+d*wynik4

Update:
MFCC zwraca równie¿ macierz kowariancji wspó³czynników + œrednie wspó³czynniki delta (coœ w rodzaju przyrostów MFCC) i ich macierz kowariancji. Do porównywania jest funkcja KLD (http://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence). Idea jest taka, ¿e wszystkie wspó³czynniki traktuje siê jako n-wymiarowy (n=13) rozk³ad normalny. KLD na razie porównuje na zasadzie normalnych wspó³czynników, ale mo¿na te¿ sprawdziæ dla tych œmiesznych delt :D
Trzebaby zamieniæ (w KLD):
  mi0 = d0$meanVal
  mi1 = d1$meanVal
  Sigma0 = d0$Sigma
  Sigma1 = d1$Sigma
na:
  mi0 = d0$Delta_meanVal
  mi1 = d1$Delta_meanVal
  Sigma0 = d0$Delta_Sigma
  Sigma1 = d1$Delta_Sigma
